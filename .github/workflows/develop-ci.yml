name: ğŸ”„ CI/CD Pipeline

on:
  push:
    branches: [develop]
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened]

# Add permissions for security scanning
permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: read

env:
  DEVELOPER_DIR: /Applications/Xcode.app/Contents/Developer
  XCODE_PROJECT: FinanceApp.xcworkspace
  SCHEME: FinanceApp

jobs:
  # Alternative commitlint approach using Node.js
  commitlint:
    name: ğŸ“ Validate Commit Messages
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install commitlint
        run: |
          npm install --save-dev @commitlint/config-conventional @commitlint/cli

      - name: Validate commit messages
        run: |
          echo "ğŸ“ Validating commit messages..."

          # Get the base and head commits
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          echo "Base SHA: $BASE_SHA"
          echo "Head SHA: $HEAD_SHA"

          # Get commit messages in the PR
          git log --format="%H %s" $BASE_SHA..$HEAD_SHA > commits.txt

          # Validate each commit message
          EXIT_CODE=0
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              COMMIT_SHA=$(echo "$line" | cut -d' ' -f1)
              COMMIT_MSG=$(echo "$line" | cut -d' ' -f2-)
              echo "Checking commit: $COMMIT_SHA"
              echo "Message: $COMMIT_MSG"
              
              # Use commitlint to check the message
              if ! echo "$COMMIT_MSG" | npx commitlint --verbose; then
                echo "âŒ Commit message validation failed for: $COMMIT_SHA"
                EXIT_CODE=1
              else
                echo "âœ… Commit message is valid for: $COMMIT_SHA"
              fi
            fi
          done < commits.txt

          if [ $EXIT_CODE -eq 0 ]; then
            echo "ğŸ‰ All commit messages are valid!"
          else
            echo "âŒ Some commit messages are invalid. Please follow conventional commit format."
            echo "ğŸ“– Learn more: https://github.com/conventional-changelog/commitlint/#what-is-commitlint"
            exit 1
          fi

  test:
    name: ğŸ§ª Run Tests & Lint
    runs-on: macos-15
    outputs:
      tests-passed: ${{ steps.test-results.outputs.tests-passed }}
      commit-sha: ${{ steps.commit-info.outputs.commit-sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get commit info
        id: commit-info
        run: |
          COMMIT_SHA="${{ github.sha }}"
          echo "commit-sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "ğŸ“ Testing commit: $COMMIT_SHA"

      - name: Check for cached test results
        id: test-cache
        uses: actions/cache@v4
        with:
          path: |
            test-results-marker
            TestResults.xcresult
          key: test-results-${{ hashFiles('**/*.swift', '**/Podfile.lock', '**/*.xcodeproj/**', '**/*.xcworkspace/**', '.github/workflows/**') }}
          restore-keys: |
            test-results-

      - name: Select Xcode version
        if: steps.test-cache.outputs.cache-hit != 'true'
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.2.0"

      - name: Cache CocoaPods
        if: steps.test-cache.outputs.cache-hit != 'true'
        uses: actions/cache@v4
        with:
          path: Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install dependencies
        if: steps.test-cache.outputs.cache-hit != 'true'
        run: |
          gem install cocoapods
          pod install --repo-update

      - name: Install SwiftLint
        if: steps.test-cache.outputs.cache-hit != 'true'
        run: |
          brew install swiftlint

      - name: Run SwiftLint
        if: steps.test-cache.outputs.cache-hit != 'true'
        run: swiftlint lint --reporter github-actions-logging

      - name: Load cached test results
        if: steps.test-cache.outputs.cache-hit == 'true'
        run: |
          echo "âœ… Using cached test results for identical code content"
          echo "ğŸš€ Tests already passed for this exact code - skipping execution"
          echo "ğŸ“ Current commit: ${{ steps.commit-info.outputs.commit-sha }}"
          if [ -f "test-results-marker" ]; then
            echo "ğŸ“Š Previous test results found and validated:"
            cat test-results-marker
          else
            echo "âš ï¸ Cache marker missing - will re-run tests as safety measure"
            echo "cache-invalid=true" >> $GITHUB_ENV
          fi

      - name: Build for testing
        if: steps.test-cache.outputs.cache-hit != 'true' || env.cache-invalid == 'true'
        run: |
          echo "ğŸ”¨ Starting build for testing..."
          echo "Workspace: ${{ env.XCODE_PROJECT }}"
          echo "Scheme: ${{ env.SCHEME }}"
          echo "Destination: iPhone 16"

          # First, let's see what's available
          xcodebuild -list -workspace ${{ env.XCODE_PROJECT }}

          # Check if the scheme exists and is valid
          xcodebuild -workspace ${{ env.XCODE_PROJECT }} \
                     -scheme ${{ env.SCHEME }} \
                     -showBuildSettings | head -20

          # Now attempt the build with verbose output
          set -o pipefail
          xcodebuild -workspace ${{ env.XCODE_PROJECT }} \
                     -scheme ${{ env.SCHEME }} \
                     -destination 'platform=iOS Simulator,name=iPhone 16,OS=latest' \
                     clean build-for-testing \
                     -verbose | xcpretty --report html --output build-report.html
        continue-on-error: true

      - name: Run unit tests
        if: steps.test-cache.outputs.cache-hit != 'true' || env.cache-invalid == 'true'
        run: |
          echo "ğŸ§ª Running tests with full build cycle..."
          # Clean up any existing test results to prevent conflicts
          rm -rf TestResults.xcresult
          xcodebuild -workspace ${{ env.XCODE_PROJECT }} \
                     -scheme ${{ env.SCHEME }} \
                     -destination 'platform=iOS Simulator,name=iPhone 16,OS=latest' \
                     test \
                     -resultBundlePath TestResults.xcresult

      - name: Mark test results as successful
        id: test-results
        if: steps.test-cache.outputs.cache-hit != 'true' || env.cache-invalid == 'true'
        run: |
          echo "âœ… Tests completed successfully"
          echo "tests-passed=true" >> $GITHUB_OUTPUT
          # Create marker file for cache validation
          echo "Test results for commit ${{ steps.commit-info.outputs.commit-sha }}" > test-results-marker
          echo "Tests passed at $(date)" >> test-results-marker
          echo "Content hash: ${{ hashFiles('**/*.swift', '**/Podfile.lock', '**/*.xcodeproj/**', '**/*.xcworkspace/**') }}" >> test-results-marker

      - name: Set cached test output
        if: steps.test-cache.outputs.cache-hit == 'true' && env.cache-invalid != 'true'
        run: |
          echo "tests-passed=true" >> $GITHUB_OUTPUT

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ github.event_name }}-${{ github.run_number }}
          path: TestResults.xcresult

      - name: Upload build logs if failed
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: build-logs-${{ github.event_name }}-${{ github.run_number }}
          path: |
            build-report.html
            ~/Library/Developer/Xcode/DerivedData/*/Logs/Build/*.xcactivitylog

      - name: Test execution summary
        if: always()
        run: |
          CONTENT_HASH="${{ hashFiles('**/*.swift', '**/Podfile.lock', '**/*.xcodeproj/**', '**/*.xcworkspace/**') }}"
          if [[ "${{ steps.test-cache.outputs.cache-hit }}" == "true" && "${{ env.cache-invalid }}" != "true" ]]; then
            echo "âš¡ Used cached test results - saved time by skipping redundant tests"
            echo "ğŸ’¡ Tests were already validated for identical code content"
            echo "ğŸ”— Content hash: ${CONTENT_HASH:0:12}..."
          else
            echo "ğŸ”„ Executed fresh tests for commit ${{ steps.commit-info.outputs.commit-sha }}"
            echo "ğŸ“¦ Results cached for future runs of identical code"
            echo "ğŸ”— Content hash: ${CONTENT_HASH:0:12}..."
          fi

  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true # Don't fail the workflow if code scanning is not enabled

      - name: Upload security scan artifact (fallback)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results-${{ github.run_number }}
          path: trivy-results.sarif

      - name: Display security scan summary
        if: always()
        run: |
          echo "ğŸ”’ Security scan completed!"
          echo "ğŸ“„ SARIF results saved as artifact: security-scan-results-${{ github.run_number }}"
          if [ -f "trivy-results.sarif" ]; then
            echo "ğŸ“Š Scan file size: $(du -h trivy-results.sarif | cut -f1)"
            echo "ğŸ’¡ To enable automatic security alerts:"
            echo "   1. Go to repository Settings"
            echo "   2. Navigate to 'Code security and analysis'"
            echo "   3. Enable 'Code scanning' under 'GitHub Advanced Security'"
          fi

  semantic-version-develop:
    name: ğŸ“¦ Development Versioning
    runs-on: ubuntu-latest
    needs: [test]
    # Run on pushes to develop OR when manually triggered
    if: (github.ref == 'refs/heads/develop' && github.event_name == 'push') || github.event_name == 'workflow_dispatch'
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Semantic Release (Development)
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        with:
          semantic_version: 22
          extra_plugins: |
            @semantic-release/changelog@6.0.0
            @semantic-release/git@10.0.0
          dry_run: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Development Release Summary
        if: steps.semantic.outputs.new_release_published == 'true'
        run: |
          echo "ğŸ‰ New development release: v${{ steps.semantic.outputs.new_release_version }}"
          echo "ğŸ“ This version is ready for development and testing"
          echo "ğŸš€ When ready for production, create a PR to main branch"

      - name: Update package.json version
        if: steps.semantic.outputs.new_release_published == 'true'
        run: |
          NEW_VERSION="${{ steps.semantic.outputs.new_release_version }}"
          echo "ğŸ“¦ Version updated to: $NEW_VERSION"
          echo "This version can be used for local development and testing"

  build-verification:
    name: ğŸ—ï¸ Build Verification
    runs-on: macos-15
    needs: [test, semantic-version-develop]
    # Run if semantic versioning job completed (regardless of whether new release was published)
    # or if we're on develop branch and tests passed
    if: always() && needs.test.result == 'success' && (needs.semantic-version-develop.result == 'success' || (github.ref == 'refs/heads/develop' && github.event_name == 'push'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: develop

      - name: Select Xcode version
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.2.0"

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install dependencies
        run: |
          gem install cocoapods
          pod install --repo-update

      - name: Verify release build (Simulator only)
        run: |
          echo "ğŸ”¨ Building release version for verification..."

          if [[ "${{ needs.semantic-version-develop.outputs.new_release_published }}" == "true" ]]; then
            echo "ğŸ“¦ Building version ${{ needs.semantic-version-develop.outputs.new_release_version }}"
            VERSION_INFO="Version ${{ needs.semantic-version-develop.outputs.new_release_version }}"
          else
            echo "ğŸ“¦ Building current develop branch (no new release)"
            VERSION_INFO="Current develop build"
          fi

          xcodebuild -workspace ${{ env.XCODE_PROJECT }} \
                     -scheme ${{ env.SCHEME }} \
                     -configuration Release \
                     -destination 'platform=iOS Simulator,name=iPhone 16,OS=latest' \
                     clean build
                     
          echo "âœ… Release build verification successful!"
          echo "ğŸ“± $VERSION_INFO is ready"
          echo "ğŸ’¡ This build is simulator-only (no device/archive needed for development)"
